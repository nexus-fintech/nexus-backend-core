package com.nexus.backend.loan.domain.model.aggregates;

import com.nexus.backend.loan.domain.model.commands.RequestLoanCommand;
import com.nexus.backend.loan.domain.model.entities.ScheduleEntry;
import com.nexus.backend.loan.domain.model.valueobjects.InterestRate;
import com.nexus.backend.loan.domain.model.valueobjects.LoanStatus;
import com.nexus.backend.loan.domain.model.valueobjects.Money;
import com.nexus.backend.shared.domain.model.aggregates.AuditableAbstractAggregateRoot;
import jakarta.persistence.*;
import lombok.Getter;
import lombok.NoArgsConstructor;

import java.time.LocalDate;
import java.util.ArrayList;
import java.util.List;

/**
 * Main Aggregate of the Loan Bounded Context.
 * Manages the loan lifecycle, status, and payment schedule.
 */
@Entity
@Getter
@NoArgsConstructor // Requerido por JPA
public class Loan extends AuditableAbstractAggregateRoot<Loan> {

    // Reference to the Client Aggregate (Foreign Key - NOT the full entity)
    @Column(nullable = false)
    private Long clientId;

    @Embedded
    @AttributeOverrides({@AttributeOverride(name = "amount", column = @Column(name = "requested_amount"))})
    private Money requestedAmount;

    @Embedded
    @AttributeOverrides({@AttributeOverride(name = "rate", column = @Column(name = "annual_interest_rate"))})
    private InterestRate annualInterestRate;

    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    private LoanStatus status;

    @Column(nullable = false)
    private int termInMonths; // Plazo en meses

    private LocalDate disbursementDate; // Disbursement date (only when ACTIVE)

    // Internal entities (Amortization Schedule)
    @OneToMany(cascade = CascadeType.ALL, fetch = FetchType.LAZY, orphanRemoval = true)
    @JoinColumn(name = "loan_id", nullable = false)
    private List<ScheduleEntry> scheduleEntries = new ArrayList<>();

    public Loan(RequestLoanCommand command) {
        this.clientId = command.clientId();
        this.requestedAmount = new Money(command.requestedAmount());
        this.annualInterestRate = new InterestRate(command.annualInterestRate());
        this.termInMonths = command.termInMonths();
        this.status = LoanStatus.REQUESTED;
        // Disbursement date remains null until the loan is APPROVED
    }

    /**
     * Business Method: Marks the loan as APPROVED and assigns the payment schedule.
     * @param schedule Payment installments generated by the Domain Service.
     */
    public void approve(List<ScheduleEntry> schedule) {
        if (this.status != LoanStatus.REQUESTED) {
            throw new IllegalStateException("Only requested loans can be approved.");
        }
        this.status = LoanStatus.ACTIVE;
        this.disbursementDate = LocalDate.now();
        this.scheduleEntries.addAll(schedule);
        // Aquí se registraría un Domain Event: LoanApprovedEvent
    }

    // Here you would go other business methods: reject(), registerPayment(), checkDefault(), etc.

    /**
     * Business Method: Rejects the loan request.
     * Only loans in REQUESTED status can be rejected.
     */
    public void reject() {
        if (this.status != LoanStatus.REQUESTED) {
            throw new IllegalStateException("Only requested loans can be rejected.");
        }
        this.status = LoanStatus.REJECTED;
    }
}